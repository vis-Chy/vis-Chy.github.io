<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Make a voronoi map</title>
    <meta name="description" content="d3-voronoi-treemap plugin to remake 'The Costs of Being Fat, in Actual Dollars'">
    <script src="libs/d3.v6.min.js" charset="utf-8"></script>
    <script src="libs/d3-weighted-voronoi.js"></script>
    <script src="libs/d3-voronoi-map.js"></script>
    <script src="libs/d3-voronoi-treemap.js"></script>
    <script src="libs/rounded-corners.js"></script>
    <script src="libs/chroma.min.js"></script>
    <script src="libs/dat.gui.min.js"></script>
    <script src="libs/saveAsSvgAsPng.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/seedrandom/3.0.5/seedrandom.min.js"></script>
    <style>
      body{
        width: 100%;
        height: 100%;
        margin: 0;
        background-color: rgb(250,250,250);
        /* overflow: hidden; */
      }
      #controlpad{
        background-color: antiquewhite;
      }
      svg {
        background-color: rgb(250,250,250);
      }
      #title {
        letter-spacing: 4px;
        font-weight: 700;
        font-size: x-large;
      }
      
      text.tiny {
        font-size: 10pt;
      }
      text.light {
        fill: lightgrey
      }
      
      .world {
        stroke: lightgrey;
		    stroke-width: 1.5px;
      }
      
      .cell {
        stroke: white;
      }
      
      .label {
        text-anchor: middle;
        fill: black;
      }
      
      .label>.name {
        dominant-baseline: text-after-edge;
      }
      
      .label>.value {
        dominant-baseline: text-before-edge;
      }
      
      .hoverer {
        fill: transparent;
        stroke: white;
        stroke-width:0px;
      }
      
      .hoverer:hover {
        /* stroke-width: 3px; */
      }

      .legend-color {
        stroke-width: 1px;
      }
      #instruction{
        font-size: 12px;
        color: black;
        position: fixed;
        bottom: 5px;
        left: 10px;
      }
      .mui-tooltip{
        display: none;
      }
      .slider{
        margin: 10px auto;
      }
      .sliderLabel{
        font-size: 14px;
        font-weight: bold;
      }
      .rangeInput{
        width: 170px;
      }
      #inputFile{
        display: none;
      }
    </style>
  </head>
  <body>
      <input type="file" name="" id="inputFile">
      <svg></svg>

    <div id="instruction">请使用chrome浏览器打开</div>
    
    <script>
    ////// chrome only! 鼠标交互不兼容firefox //////
    ////// 参考资料 //////
    ////// https://bl.ocks.org/Kcnarf/raw/fa95aa7b076f537c00aed614c29bb568 //////
    ////// https://bl.ocks.org/mbostock/76456029b13c68accf6e //////
    ////// https://bl.ocks.org/Kcnarf/b2212ceafc875aac0e02a153fe9ff330 //////
    ////// https://www.swayable.com/insights/primaries2019 //////
     


      var _2PI = 2*Math.PI;
      
      var svgWidth = window.innerWidth;
      var svgHeight = window.innerHeight;

      var margin = {top: 10, right: 20, bottom: 10, left: 20},
          height = svgHeight - margin.top - margin.bottom,
          width = svgWidth - margin.left - margin.right,
          halfWidth = width/2,
          halfHeight = height/2,
          quarterWidth = width/4,
          quarterHeight = height/4,
          titleY = 20,
          legendsMinY = height - 20,
          treemapCenter = [halfWidth, halfHeight+5];
      
      let loadtype = "json";

      //可交互变量
      var options = {
        'Upload Data': function(){
            // you need to create an input element in HTML.
            var input = document.getElementById('inputFile');
            input.addEventListener('change', function() {
              // 获取到文件
              var file = this.files[0];
              // 创建读取器
              var reader = new FileReader();
              // 开始读取
              reader.readAsText(file);
              // 文件读取完成后，获取读取的结果
              reader.onload = function() {
                var content = reader.result;
                switch (file.type) {
                  case "text/csv":
                    loadtype = "csv"
                    table = d3.csvParse(content);
                    options.titleName = '';
                    draw(table)
                  break;
                  case "application/json":
                    loadtype = "json"
                    content = JSON.parse(content)
                    options.titleName = '';
                    draw(content)
                  break;
                  default:
                    alert("无选中文档")
                }
              }
            // r.readAsDataURL(file);
            // for (var i in gui.__controllers) {
            //   gui.__controllers[i].updateDisplay();
            // }
          });
          input.click();
        },
        titleName: "The Global Economy by GDP (as of 01/2017)",//标题
        treemapRadius: 265,
        roundFac: 0, //尖-圆，(-1,2]。最大值可无穷大但没必要
        cellsInterval: 4, //窄-宽，[0,8)
        fixfontsize: true, //false为固定大小，ture为自适应大小
        namefontsize: 12,
        valuefontsize: 9,
        valueUnit: "%",
        lablesAmount: 0.006, //多-少，[0,0.1]。0.1即为占10%，大小较为足够了
        Save : function(){
          saveSvgAsPng(document.getElementsByTagName("svg")[0], "voronoi-map.png");
        },
        SaveSvg : function(){
          saveSvg(document.getElementsByTagName("svg")[0], "voronoi-map.svg")
        },
      };

      var _voronoiTreemap = d3.voronoiTreemap();
      var hierarchy, circlingPolygon, circleingOutline;
      let data;
     
      var color_array;
      const colors = ["#7160d8", "#eb00b1", "#fb0017", "#ff8e08", "#ffd744", "#60cc4b", "#12cfcf", "#328fe6"]
      const color_scale = chroma.scale(colors)
        .nodata("rgb(220,220,220)")
        .mode("lab")//"lab", "hsl" "lrgb" "lch"

      var fontScale = d3.scaleLinear();
      
      const area_scale = d3.scaleSqrt()
        .domain([0, 100000])
        .range([4, 30]);
      
      var svg, drawingArea, treemapContainer;
      
      window.onload = function() { 
        //默认加载
        d3.json("globalEconomyByGDP.json").then(function(rootData) {
          draw(rootData);
        });

        //控制器事实加载
        gui = new dat.GUI();  //控制器
        var folder1 = gui.addFolder('Controls');
        var UploadData = folder1.add(options, 'Upload Data');

        titleControl = folder1.add(options, 'titleName');
        titleControl.onChange(function(){ draw(data) });

        radiusControl = folder1.add(options, 'treemapRadius', 0 , 400);
        radiusControl.onChange(function(){ draw(data) });

        roundControl = folder1.add(options, 'roundFac', -0.999 , 3);
        roundControl.onChange(function(){ draw(data) });

        intervalControl = folder1.add(options, 'cellsInterval', 0.1 , 7.999);
        intervalControl.onChange(function(){ draw(data) });

        unitControl = folder1.add(options, 'valueUnit');
        unitControl.onChange(function(){ draw(data) });

        lablesControl = folder1.add(options, 'lablesAmount', 0 , 0.1);
        lablesControl.onChange(function(){ draw(data) });

        var folder2 = gui.addFolder('Font size');
        isFixedControl = folder2.add(options, 'fixfontsize');
        isFixedControl.onChange(function(d){ 
          if (d) {
            //不可修改字号
            nameSizeControl.remove();
            valueSizeControl.remove();
          }else{
            nameSizeControl = folder2.add(options, 'namefontsize', 0 , 20);
            nameSizeControl.onChange(function(){ draw(data) });

            valueSizeControl = folder2.add(options, 'valuefontsize', 0 , 20);
            valueSizeControl.onChange(function(){ draw(data) });
          }
          draw(data) });
        
        var folder3 = gui.addFolder('Save');
        SaveControl = folder3.add(options, 'Save');
        SaveSvgControl = folder3.add(options, 'SaveSvg');


        folder1.open();
        folder2.open();
      };

      //主函数，所有运算都发生于此
      function draw(data) {
        switch (loadtype) {
            case "json":
              drawJson(data)
              break;
            case "csv":
              drawCsv(data)
              break;
          }
      }

      function drawJson(rootData) {
        data = rootData;

        //d3.voronoiTreemap(),必须基于固定格式的d3-hierarchy进行，且必须计算hierarchy,sum()作为权值
        hierarchy = d3.hierarchy(rootData).sum(function(d){ return d.weight; });
        initData();
        initLayout(hierarchy);
        //define the tessellation
        _voronoiTreemap = _voronoiTreemap.clip(circlingPolygon)// sets the clipping polygon
        _voronoiTreemap(hierarchy);// computes the weighted Voronoi tessellation of the d3-hierarchy; assigns a 'polygon' property to each node of the hierarchy
        //set prng to produce the exact same final arrangement.
        var mySeededPrng = new Math.seedrandom('my seed'); // (from seedrandom's doc) Use "new" to create a local prng without altering Math.random
        _voronoiTreemap.prng(mySeededPrng);
        //draw cells
        drawTreemap(hierarchy);
      }

      function drawCsv(table) {
        data = table;
        var root = d3.stratify()
                .id(function(d) { return d.name; })
                .parentId(function(d) { return d.parent; })
              (table);
        //d3.voronoiTreemap(),必须基于固定格式的d3-hierarchy进行，且必须计算hierarchy,sum()作为权值
        hierarchy = root.sum(function(d){ 
                d.weight = parseFloat(d.weight)
                return d.weight; 
        });
        initData();
        initLayout(root);
        //define the tessellation
        _voronoiTreemap = _voronoiTreemap.clip(circlingPolygon)// sets the clipping polygon
        _voronoiTreemap(hierarchy);// computes the weighted Voronoi tessellation of the d3-hierarchy; assigns a 'polygon' property to each node of the hierarchy
        //set prng to produce the exact same final arrangement.
        var mySeededPrng = new Math.seedrandom('my seed'); // (from seedrandom's doc) Use "new" to create a local prng without altering Math.random
        _voronoiTreemap.prng(mySeededPrng);
        //draw cells
        drawTreemap(hierarchy);
      }
      
      
      //其它函数声明
      function initData() {
        circlingPolygon = computeCirclingPolygon(options.treemapRadius);//此circle用于绑定tessellation范围
        circleingOutline = computeCirclingPolygon(options.treemapRadius + 4)//此circle用于绘制作为外边框。设置扩大半径比多边形范围略大
        fontScale.domain([3, 20]).range([9, 16]).clamp(true); //设置字体大小渐变范围
      }
      
      function computeCirclingPolygon(radius) {
        var points = 120,
            increment = _2PI/points,
            circlingPolygon = [];
        
        for (var a=0, i=0; i<points; i++, a+=increment) {
          circlingPolygon.push(
            [radius + radius*Math.cos(a), radius + radius*Math.sin(a)]//用path画圆，用短直线段一节节画，分段数用points值调节。
          )
        }
        
      	return circlingPolygon;
      };
      
      function initLayout(rootData) {
        svg = d3.select("svg")
          .attr("width", svgWidth)
          .attr("height", svgHeight);

        svg.selectAll(".drawingArea").remove();

        drawingArea = svg.append("g")
        	.classed("drawingArea", true)
        	.attr("transform", "translate("+[margin.left,margin.top]+")");
        
        treemapContainer = drawingArea.append("g")
        	.classed("treemap-container", true)
        	.attr("transform", "translate("+treemapCenter+")");
        
        treemapContainer.append("path")
        	.classed("world", true)
        	.attr("transform", "translate("+[-options.treemapRadius-4,-options.treemapRadius-4]+")")
        	.attr("d", "M"+circleingOutline.join(",")+"Z")//绘制外接形状
          .style("fill","white")
        
        drawTitle(options.titleName);

        setupColorScale();
        function setupColorScale() {
        //Get the distinct colors
        let colors_needed = color_scale.colors(hierarchy.children.length)
        color_array = []
        for(let i = 0; i < hierarchy.children.length; i++) {
            color_array.push({
                color: colors_needed[i],
                name: hierarchy.children[i].data.name
            })
          }
        }
        drawLegends(hierarchy);
      }
      
      function drawTitle(titleText) {
        drawingArea.append("text")
        	.attr("id", "title")
        	.attr("transform", "translate("+[halfWidth, titleY+20]+")")
        	.attr("text-anchor", "middle")
          .text(titleText)
      }
      
      function drawLegends(hierarchy) {

        var legendHeight = 13,
            interLegend = 4,
            colorWidth = legendHeight*2,
            classes = hierarchy.children.reverse();
        
        var legendContainer = drawingArea.append("g")
        	.classed("legend", true)
        	.attr("transform", "translate("+[0, legendsMinY]+")");
        
        var legends = legendContainer.selectAll(".legend")
        	.data(classes)
        	.enter();
        
        var legend = legends.append("g")
        	.classed("legend", true)
        	.attr("transform", function(d,i){
            return "translate("+[10, -i*(legendHeight + interLegend)]+")";
          })
        	
        legend.append("rect")
        	.classed("legend-color", true)
        	.attr("y", -legendHeight)
        	.attr("width", colorWidth)
        	.attr("height", legendHeight)
        	.style("fill", function(d){
            var c;
            color_array.forEach(a => {
              if (a.name === d.data.name){c = a.color}})
            return c;
            // return d.color
          });
        legend.append("text")
        	.classed("tiny", true)
        	.attr("transform", "translate("+[colorWidth+5, -2]+")")
        	.text(function(d){ return d.data.name; });

      }
      
      function drawTreemap(hierarchy) {
        var leaves=hierarchy.leaves();
        
        var cells = treemapContainer.append("g")
        	.classed('cells', true)
        	.attr("transform", "translate("+[-options.treemapRadius,-options.treemapRadius]+")")
	        .selectAll(".cell")
        	.data(leaves)
        	.enter()
        		.append("g")
            .classed("cell", true)

        cells.append("path")
          .classed("cellpath", true)
          // .attr("d", function(d){ return "M"+d.polygon.join(",")+"z"; })
          .attr("d", (d,i) => {
                d.data.area = d3.polygonArea(d.polygon)
                return drawRoundedPolygon(d.polygon, area_scale(d.data.area)+options.roundFac*area_scale(d.data.area)) //rounded-corners.js
            })
          .style("fill", function(d){
            var n;
            if (d.depth >= 2){
              n = d.parent.data.name
            }
            else{
              n = d.data.name
            }
            var c;
            color_array.forEach(a => {
              if (a.name === n){c = a.color}})
            return c;
            // return d.parent.data.color;
          })
          .style("stroke-width", options.cellsInterval + "px");
          
        
        var labels = treemapContainer.append("g")
        	.classed('labels', true)
        	.attr("transform", "translate("+[-options.treemapRadius,-options.treemapRadius]+")")
	        .selectAll(".label")
        	.data(leaves)
        	.enter()
        		.append("g")
        			.classed("label", true)
        			.attr("transform", function(d){
          			return "translate("+[d.polygon.site.x, d.polygon.site.y]+")";
              })
              .style("opacity", function(d){ return (d.data.weight/hierarchy.value < options.lablesAmount) ? 0 : 1; })
        			.style("font-size", function(d){ return fontScale(d.data.weight); });
        
        labels.append("text")
        	.classed("name", true)
        	.html(function(d){
          	return d.data.name;
        	});
        labels.append("text")
        	.classed("value", true)
        	.text(function(d){ return d.data.weight+options.valueUnit; });
        
        //字号控制，自适应字号或固定字号
        if (options.fixfontsize)
        {
          //按值的大小分配字号，文字和值的字号一同变动
        }
        else{
          //可自由修改文字和值字号大小
          labels.selectAll(".name")
            .style("font-size",options.namefontsize+"px");
          labels.selectAll(".value")
            .style("font-size",options.valuefontsize+"px");
        }

        var hoverers = treemapContainer.append("g")
        	.classed('hoverers', true)
        	.attr("transform", "translate("+[-options.treemapRadius,-options.treemapRadius]+")")
	        .selectAll(".hoverer")
        	.data(leaves)
        	.enter()
        		.append("path")
        			.classed("hoverer", true)
        			.attr("d", function(d){ return "M"+d.polygon.join(",")+"z"; })
              .on("mouseover", mouseOver)
              .on("mouseout", mouseOut);
        
        function mouseOver(d){
          var s = d.path[0].__data__.data.name
          let dur = 300

          //Raise to the top, so it overlaps all
          d3.select(this).raise()

          //Fade all the other cells
          d3.selectAll(".cell")
            .transition("fade").duration(dur)
            .style("opacity", function(a){
              return a.data.name !== s ? 0.5 : 1;
            })
          
          //Reveal the text (if it was hidden)
          d3.selectAll(".label")
            .transition("fade").duration(dur)
            .style("opacity", function(a){
              return a.data.name !== s ? 0 : 1;
            })
        }

        function mouseOut(d){
          var s = d.path[0].__data__.data.name
          let dur = 300

          //Reveal all the other cells again
          d3.selectAll(".cell")
            .transition("fade").duration(dur)
            .style("opacity", 1)
          
          //Reveal the text (if it was hidden)
          d3.selectAll(".label")
            .transition("fade").duration(dur)
            .style("opacity", function(a){
              return (a.data.weight/hierarchy.value < options.lablesAmount) ? 0 : 1;
            })
        }

      }

    </script>
  </body>
</html>